<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCA Watchlist</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/vfs_fonts.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
	    
	.ui, .container {
	    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	    padding: 20px;
    	    margin-top: 20px;
	}
		    
        .ui {
            text-align: center;
            max-width: 600px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            margin: auto;
            margin-top: 20px; /* Added margin at the top */
        }

        .container {
            text-align: center;
            max-width: 800px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
            margin: auto;
            margin-top: 20px; /* Added margin at the top */
        }

        label {
            margin-right: 10px;
        }

        button {
	    background-color: #2ecc71;
	    color: #fff;
	    border: none;
	    padding: 10px 20px;
	    cursor: pointer;
	    border-radius: 5px;
	}

	input {
	    padding: 10px;
	    border: 1px solid #ccc;
	    border-radius: 5px;
	}

        table {
	    border-collapse: collapse;
	    width: 100%;
	    margin-top: 20px;
	    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	}

        th,
        td {
            border: 1px solid #ccc;
            padding: 3px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
        }
	    
	#competitorSelect, #eventsContainer {
       	    display: none;
    	}

	#friendsContainer {
	    text-align: center;
	    margin-top: 20px;
	    margin: 20px auto; /* Remove the redundant margin property */
	    display: flex;
	    flex-direction: column; /* Stack elements vertically */
	    align-items: center; /* Center items horizontally */
	}
	
	#friendsContainer p {
	    display: inline-block; /* Keep paragraphs inline */
	    margin: 20px auto; /* Remove default margin */
	}
	
	#friendsContainer button {
	    display: inline-block; /* Make buttons block elements */
	    margin: 10px;
	}
	#addFriendsContainer {
	    text-align: center;
	    margin-top: 20px;
	}
	
	#addFriendsContainer label,
	#addFriendsContainer select,
	#addFriendsContainer button {
	    margin: 10px 0;
	}
	
	#addFriendsContainer button {
	    display: block;
	    margin: 0 auto; /* Center the button horizontally */
	}
	.popup {
	    display: none;
	    position: fixed;
	    top: 50%;
	    left: 50%;
	    transform: translate(-50%, -50%);
	    background-color: rgba(0, 0, 0, 0.7);
	    color: #fff;
	    padding: 20px;
	    border-radius: 5px;
	    animation: fadeInOut 2s ease-in-out;
	}
	
	@keyframes fadeInOut {
	    0%, 100% {
	        opacity: 0;
	    }
	    25%, 75% {
	        opacity: 1;
	    }
	}
    </style>
</head>

<body>
    <div class="ui">
        <label for="textInput">Enter Competition ID:</label>
        <input type="text" id="textInput" placeholder="Type competition ID...">
        <button onclick="getData()">Get Data</button>
        <select id="competitionSelect" onchange="autofillCompetitionId(); clearSelectedCompetitors(); getData();">
            <option value="">---Select a Competition---</option>
            <option value="cloverdaleopen2022">Cloverdale Open 2022</option>
	    <option value="canadianchampionship2023">Canadian Championship 2023</option>
            <option value="cubingaroundmetrotown2023">Cubing Around Metrotown 2023</option>
            <option value="vancouverfallfest2023">Vancouver Fall Fest 2023</option>
            <option value="canadasbestinthewest2024">Canada's Best in the West 2024</option>
	    <option value="burnabybasics2024">Burnaby Basics 2024</option>
	    
        </select>
        <select id="competitorSelect" onchange="displayResultsForCompetitor(); clearSelectedCompetitors();">
            <!-- this will be autopopulated by the page -->
        </select>
        <div id="eventsContainer"></div>
    </div>

     <div id="friendsContainer"></div>

<!-- Add Friends button -->
<div id="addFriendsContainer">
    <label for="friendSelect">Add Friends:</label>
    <select id="friendSelect" onchange="addFriend(); saveFriends();">
        <!-- Dynamically populate options using JavaScript -->
    </select>
    <button onclick="addFriend()" style="display: none;">Add Friend</button>
    <button id="autofillFriendsBtn" onclick="autofillFriends(); showAutofillPopup();">Autofill Friends' Boxes</button>
</div>
	
    <div class="container">
        <div id="resultContainer"></div>
        <div id="checkboxContainer"></div>
	    <p style="color: #888; font-size: 12px; margin-top: 5px;">
  	  Note: Only competitors with WCA IDs are eligible to be watchlisted or friended.
	</p>
        <button id="createWatchlistBtn" style="display: none;" onclick="createWatchlist()">Create Watchlist</button>
    </div>

    <!-- New section to display names and assignments -->
    <div id="selectedCompetitorsContainer">
        <h3>Selected Competitors:</h3>
        <div id="selectedCompetitorsInfo"></div>
    </div>
    
    <div id="watchlistContainer" style="display: none;">
        <h2>Watchlist</h2>
	<button id="exportPdfBtn" onclick="exportToPdf()">Export to PDF</button>
        <table id="watchlistTable">
            <!-- Table content will be dynamically added here -->
        </table>
    </div>
    

	
    <script>
    // Initialize an object to store rankings
    const rankings = {};
    let data;
    let friendsList = localStorage.getItem('friendsList') ? JSON.parse(localStorage.getItem('friendsList')) : [];
    window.jsPDF = window.jspdf.jsPDF
    window.html2canvas = html2canvas;

	
	function initializeFriendsList() {
	    console.log('Initializing friends list...');
	    loadFriends();
	    displayFriendsList();
	    console.log('Initialization complete.');
	}

		    
  	function loadFriends() {
	    try {
	        const storedFriends = localStorage.getItem('friendsList');
	        friendsList = storedFriends ? JSON.parse(storedFriends) : [];
	        console.log('Friends list loaded successfully:', friendsList);
	
	        // Call displayFriendsList() directly after loading friends
	        displayFriendsList();
	    } catch (error) {
	        console.error('Error loading friends list:', error);
	    }
	}
	
	// Call loadFriends immediately after defining it
	loadFriends();


        // Function to save friends to local storage
	function saveFriends(callback) {
	    localStorage.setItem('friendsList', JSON.stringify(friendsList));
	    if (callback && typeof callback === 'function') {
	        callback();
	    }
	}

	function isPersonInFriendsList(wcaId) {
	        return friendsList.some(friend => friend.wcaId === wcaId);
	    }
        function populateFriendDropdown() {
	    const friendSelect = document.getElementById('friendSelect');
	
	    // Clear existing options
	    friendSelect.innerHTML = '<option value="">---Select Competitor---</option>';
	
	    // Sort competitors alphabetically by name
	    const sortedCompetitors = data.persons
	        .filter(person => person.wcaId) // Only include competitors with WCA IDs
	        .sort((a, b) => a.name.localeCompare(b.name));
	
	    // Populate options based on sorted competitors
	    sortedCompetitors.forEach(person => {
	        const option = document.createElement('option');
	        option.value = person.wcaId;
	        option.textContent = person.name;
	        friendSelect.appendChild(option);
	    });
	}

        // Call populateFriendDropdown when the page loads
        window.addEventListener('load', populateFriendDropdown);

        // Function to check checkboxes for friends
        function checkFriends() {
	    displayFriendsList();
            friendsList.forEach(friend => {
                const checkbox = document.getElementById(friend);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
        }

        // Call loadFriends when the page loads
        window.addEventListener('load', loadFriends);

	function autofillFriends() {
    const checkboxes = document.getElementsByName('competitorCheckbox');
    const friendsNames = friendsList.map(friend => friend.name.toLowerCase());  // Use friend.name

    checkboxes.forEach(checkbox => {
        const person = data.persons.find(person => person.wcaId === checkbox.value);
        if (person) {
            const personName = person.name.toLowerCase();

            // Check if friend's name matches the competitor's name
            if (friendsNames.includes(personName)) {
                checkbox.checked = true;
            }
        }
    });
	handleCheckboxChange(event)
	displayFriendsList();
}
	function showPopup(message) {
	    const popup = document.getElementById('popup');
	    const popupText = document.getElementById('popupText');
	
	    if (popup && popupText) {
	        popupText.textContent = message;
	        popup.style.display = 'block';
	
	        // Hide the popup after 2 seconds (adjust as needed)
	        setTimeout(() => {
	            popup.style.display = 'none';
	        }, 2000);
	    }
	}
	
	// Call this function when the autofillFriendsBtn is clicked
	function showAutofillPopup() {
	    showPopup('Friends have been selected!');
	}
	    
	function addFriend() {
            const friendSelect = document.getElementById('friendSelect');
            const selectedWcaId = friendSelect.value;

            if (selectedWcaId) {
                const person = data.persons.find(person => person.wcaId === selectedWcaId);

                if (person) {
                    const friendName = person.name.trim();

                    // Check if the person is already in the friends list
                    if (!isPersonInFriendsList(selectedWcaId)) {
                        // Append the friend to the friends container
                        const friendsContainer = document.getElementById('friendsContainer');
                        friendsContainer.innerHTML += `<p>${friendName}</p>`;

                        // Clear the selected option
                        friendSelect.value = '';

                        // Save the updated friends list to local storage
                        friendsList.push({ wcaId: person.wcaId, name: friendName });
			    saveFriends();
			    console.log('Friend added:', { wcaId: person.wcaId, name: friendName });

                    } else {
                        alert(`${friendName} is already in the friends list.`);
                    }
                }
            }
		displayFriendsList();
        }
    function removeFriendOnClick(wcaId, event) {
    // Remove the friend from the friends list
    friendsList = friendsList.filter(friend => friend.wcaId !== wcaId);

    // Save the updated friends list to local storage
    saveFriends(() => {
	    console.log('Friend removed:', wcaId);
        // Callback function to execute after saving is complete
        // Re-populate the friend dropdown
        populateFriendDropdown();

        // Trigger handleCheckboxChange after removing a friend
        handleCheckboxChange(event);

        // Update the displayed friends list
        displayFriendsList();
    });
}

	    
    function displayFriendsList() {
    const friendsContainer = document.getElementById('friendsContainer');
    friendsContainer.innerHTML = '<h3>Friends List:</h3>';

    // Display friends list dynamically
    friendsList.forEach(friend => {
        const friendContainer = document.createElement('div');

        // Create a paragraph for the friend's name
        const paragraph = document.createElement('p');
        paragraph.textContent = friend.name;

        // Create a button to remove the friend
        const removeButton = document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.onclick = (event) => removeFriendOnClick(friend.wcaId, event);

        // Append the paragraph and button to the friend container
        friendContainer.appendChild(paragraph);
        friendContainer.appendChild(removeButton);

        // Append the friend container to the friends container
        friendsContainer.appendChild(friendContainer);
    });

    // Save friends after displaying the updated list
    saveFriends();
}

// Call loadFriends when the page content is loaded
document.addEventListener('DOMContentLoaded', loadFriends);
	    
    function getData() {
        // Get user input
        const userInput = document.getElementById('textInput').value;
	clearSelectedCompetitors();

        // Make an API call to World Cube Association API
        fetch(`https://api.worldcubeassociation.org/competitions/${userInput}/wcif/public?name`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json(); // Change to response.json() to parse JSON directly
            })
            .then(dataObject => {
                // Log the entire API response (for debugging purposes)
                console.log('API Response:', dataObject);

                // Display the entire API response as a string below the input
                const resultContainer = document.getElementById('resultContainer');
                // resultContainer.textContent = JSON.stringify(dataObject, null, 2);

                // Call the function to format and display data
                formatAndDisplayData(dataObject);

		displayCompetitorCheckboxes(data);

		populateFriendDropdown();
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                // Handle errors gracefully
            });
    }
	    
    function clearSelectedCompetitors() {
            // Clear the selected competitors list and related information
            const checkboxContainer = document.getElementById('checkboxContainer');
            checkboxContainer.innerHTML = '<h3>Select Competitors:</h3>';

            const selectedCompetitorsInfo = document.getElementById('selectedCompetitorsInfo');
            selectedCompetitorsInfo.innerHTML = '';

            const selectedCompetitorsContainer = document.getElementById('selectedCompetitorsContainer');
            selectedCompetitorsContainer.style.display = 'none';

            const createWatchlistBtn = document.getElementById('createWatchlistBtn');
            createWatchlistBtn.style.display = 'none';
        }
	    
    function formatAndDisplayData(dataObject) {
        // Store the data globally for later use
        data = dataObject;

        // Initialize an array to store group information
        const groups = [];

        // Display other details excluding rankings
        const formattedData = `
            Format Version: ${dataObject.formatVersion}
            Competition ID: ${dataObject.id}
            Competition Name: ${dataObject.name}
            Start Date: ${dataObject.schedule.startDate}
            Number of Days: ${dataObject.schedule.numberOfDays}
            Venue: ${dataObject.schedule.venues[0].name}
            Latitude: ${dataObject.schedule.venues[0].latitudeMicrodegrees}
            Longitude: ${dataObject.schedule.venues[0].longitudeMicrodegrees}
            
            --- Persons ---
            ${dataObject.persons.map(person => {
                // Save rankings to the 'rankings' object
                rankings[person.wcaId] = person.personalBests.map(pBest => ({
                    eventId: pBest.eventId,
                    worldRanking: pBest.worldRanking,
                    nationalRanking: pBest.nationalRanking,
                }));

                // Display other details excluding rankings
                return `
                    Name: ${person.name}
                    WCA ID: ${person.wcaId}
                    Country: ${person.countryIso2}
                    Gender: ${person.gender}
                    Assignments: ${person.assignments.map(assignment => `
                        Activity ID: ${assignment.activityId}
                        Assignment Code: ${assignment.assignmentCode}
                    `).join('\n')}
                    -----------------
                `;
            }).join('\n')}
            
            --- Events ---
            ${dataObject.events.map(event => `
                Event ID: ${event.id}
                Rounds: ${event.rounds.map(round => `
                    Round ID: ${round.id}
                    Format: ${round.format}
                    Time Limit: ${round.timeLimit}
                    Cutoff: ${round.cutoff}
                    Advancement Condition: ${round.advancementCondition}
                    Results: ${round.results.map(result => `
                        Person ID: ${result.personId}
                        Ranking: ${result.ranking}
                        Best: ${result.best}
                        Average: ${result.average}
                    `).join('\n')}
                `).join('\n')}
            `).join('\n')}
    
            --- Schedule ---
            ${dataObject.schedule.venues[0].rooms[0].activities.map(activity => {
                // Check if the activity has child activities
                if (activity.childActivities && activity.childActivities.length > 0) {
                    // Handle group information
                    activity.childActivities.forEach(group => {
                        groups.push({
                            groupId: group.id,
                            groupName: group.name,
                            activityCode: group.activityCode,
                            startTime: group.startTime,
                        });
                    });
    
                    return `
                        Activity ID: ${activity.id}
                        Name: ${activity.name}
                        Activity Code: ${activity.activityCode}
                        Start Time: ${activity.startTime}
                        End Time: ${activity.endTime}
                    `;
                } else {
                    // Handle regular activity without groups
                    return `
                        Activity ID: ${activity.id}
                        Name: ${activity.name}
                        Activity Code: ${activity.activityCode}
                        Start Time: ${activity.startTime}
                        End Time: ${activity.endTime}
                    `;
                }
            }).join('\n')}
        `;

        // Store the groups array in the data object
        data.groups = groups;

        // Display the formatted data
        // document.getElementById('resultContainer').textContent = formattedData;

        const eventsContainer = document.getElementById('eventsContainer');
        eventsContainer.innerHTML = ''; // Clear existing event buttons

        // Display event buttons dynamically
        dataObject.events.forEach(event => {
            const button = document.createElement('button');
            button.textContent = `View Results - ${event.id}`;
            button.addEventListener('click', () => displayResultsForEvent(event, dataObject));
            eventsContainer.appendChild(button);
        });

        // Populate the competitor dropdown dynamically
        const competitorSelect = document.getElementById('competitorSelect');
        competitorSelect.innerHTML = '<option value="main">Select Competitor</option>';
        dataObject.persons.forEach(person => {
            const option = document.createElement('option');
            option.value = person.wcaId;
            option.textContent = person.name;
            competitorSelect.appendChild(option);
        });
    }

    function displayResultsForEvent(event, dataObject) {
    const formattedEventData = `
        Event ID: ${event.id}
        Rounds: ${event.rounds.map(round => `
            Round ID: ${round.id}
            Format: ${round.format}
            Time Limit: ${round.timeLimit}
            Cutoff: ${round.cutoff}
            Advancement Condition: ${round.advancementCondition}
            Results: ${round.results.map(result => `
                Person ID: ${result.personId}
                Ranking: ${result.ranking}
                Best: ${result.best}
                Average: ${result.average}
            `).join('\n')}
        `).join('\n')}
    `;

    // Extract round information (e.g., "Round 2, 1") from the event data
    const roundInfo = event.rounds.map(round => `Round ${round.id}, ${round.number}`).join(', ');

    // Display the formatted event data along with round information
    document.getElementById('resultContainer').innerHTML = `
        <h3>Event Information</h3>
        ${formattedEventData}
        <p>Round Information: ${roundInfo}</p>
    `;
}

    function autofillCompetitionId() {
        const selectElement = document.getElementById('competitionSelect');
        const inputElement = document.getElementById('textInput');
        inputElement.value = selectElement.value;
    }

    function displayResultsForCompetitor() {
        const selectedWcaId = document.getElementById('competitorSelect').value;

        if (selectedWcaId === 'main') {
            // Display the dynamic list of checkboxes
            document.getElementById('resultContainer').textContent = ''; // Clear the result container
            displayCompetitorCheckboxes(data);
        } else {
            const competitorRankings = rankings[selectedWcaId];
            const formattedCompetitorData = `
                --- Competitor Rankings ---
                ${competitorRankings.map(ranking => `
                    Event ID: ${ranking.eventId}
                    World Ranking: ${ranking.worldRanking}
                    National Ranking: ${ranking.nationalRanking}
                `).join('\n')}
            `;

            // Display the formatted competitor data
            document.getElementById('resultContainer').textContent = formattedCompetitorData;

            // Call the function to display assignments with the 'data' object
            displayAssignmentsForCompetitor(selectedWcaId, data);
        }
    }

    function displayCompetitorCheckboxes(dataObject) {
        const checkboxContainer = document.getElementById('checkboxContainer');
        checkboxContainer.innerHTML = '<h3>Select Competitors:</h3>';

        // Filter out competitors without a WCA ID
        const filteredPersons = dataObject.persons.filter(person => person.wcaId);

        // Sort persons array alphabetically by name
        const sortedPersons = filteredPersons
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));

        sortedPersons.forEach(person => {
            // Exclude "Speedcubing Canada" from the checkbox list
            if (person.name !== 'Speedcubing Canada') {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'competitorCheckbox';
                checkbox.value = person.wcaId;
                checkbox.id = person.wcaId;

                const label = document.createElement('label');
                label.htmlFor = person.wcaId;
                label.appendChild(document.createTextNode(person.name));

                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                checkboxContainer.appendChild(document.createElement('br'));
            }
        });

        // Attach event listener to handle checkbox changes
        checkboxContainer.addEventListener('change', function (event) {
            if (event.target.name === 'competitorCheckbox') {
                handleCheckboxChange(event); // Pass the event object
            }
        });

        // Show the "Create Watchlist" button
        const createWatchlistBtn = document.getElementById('createWatchlistBtn');
        createWatchlistBtn.style.display = 'block';

        console.log('Checkboxes displayed:', sortedPersons.map(person => person.name));
    }

    function handleCheckboxChange(event) {
        const checkboxes = document.getElementsByName('competitorCheckbox');
        const selectedCheckboxes = Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);

        // Filter out competitors without a WCA ID
        const validSelectedCheckboxes = selectedCheckboxes.filter(wcaId =>
            data.persons.find(person => person.wcaId === wcaId)
        );

        // Log information about the clicked checkbox and its status
        console.log('Clicked checkbox:', {
            id: event.target.id,
            value: event.target.value,
            checked: event.target.checked,
        });

        // Update the "Compete" column in the watchlist table
        updateCompeteColumn(validSelectedCheckboxes);

        // Display names and assignments for selected competitors
        displaySelectedCompetitorsInfo(validSelectedCheckboxes);
    }
        
    function displaySelectedCompetitorsInfo(selectedWcaIds) {
            const selectedCompetitorsInfo = document.getElementById('selectedCompetitorsInfo');
            selectedCompetitorsInfo.innerHTML = '';

            selectedWcaIds.forEach(wcaId => {
                const person = data.persons.find(person => person.wcaId === wcaId);
                if (person) {
                    const assignmentsInfo = person.assignments.map(assignment => `
                        Activity ID: ${assignment.activityId}
                        Assignment Code: ${assignment.assignmentCode}
                    `).join('<br>');

                    const competitorInfo = `
                        <strong>${person.name}</strong><br>
                        WCA ID: ${person.wcaId}<br>
                        Country: ${person.countryIso2}<br>
                        Gender: ${person.gender}<br>
                        
                        -----------------<br>
                    `;
			// Assignments:<br>${assignmentsInfo}<br>

                    selectedCompetitorsInfo.innerHTML += competitorInfo;
                }
            });

            // Show the selected competitors container
            const selectedCompetitorsContainer = document.getElementById('selectedCompetitorsContainer');
            selectedCompetitorsContainer.style.display = 'block';
        }

        
    function displayAssignmentsForCompetitor(selectedWcaId, dataObject) {
        const person = dataObject.persons.find(person => person.wcaId === selectedWcaId);

        if (person) {
            const formattedAssignments = `
                --- Competitor Assignments ---
                ${person.assignments.map(assignment => `
                    Activity ID: ${assignment.activityId}
                    Assignment Code: ${assignment.assignmentCode}
                `).join('\n')}
            `;

            // Display the formatted assignments
            document.getElementById('resultContainer').textContent += formattedAssignments;
        }
    }

    function updateCompeteColumn(selectedWcaIds) {
    const watchlistTable = document.getElementById('watchlistTable');

    // Iterate through the rows in the watchlist table
    for (let i = 1; i < watchlistTable.rows.length; i++) {
        const row = watchlistTable.rows[i];
        const groupID = row.cells[1].textContent;

        // Get all assignments for the group
        const groupAssignments = [];

        selectedWcaIds.forEach(wcaId => {
            const person = data.persons.find(person => person.wcaId === wcaId);
            if (person) {
                const assignmentsForGroup = person.assignments.filter(assignment =>
                    assignment.activityId === groupID
                );
                groupAssignments.push(...assignmentsForGroup);
            }
        });

        // Check if there are assignments with the "competitor" code
        const competitorAssignments = groupAssignments.filter(assignment =>
            assignment.assignmentCode === 'competitor'
        );

        if (competitorAssignments.length > 0) {
            // Update the "Compete" cell with the names of selected competitors
            const competeCell = row.cells[3];

            // Get the names of selected competitors
            const names = selectedWcaIds
                .map(wcaId => data.persons.find(person => person.wcaId === wcaId))
                .filter(competitor => competitor)
                .map(competitor => competitor.name);

            competeCell.textContent = names.join(', ');
        }
    }
}

        
    function createWatchlist() {
    const watchlistContainer = document.getElementById('watchlistContainer');
    const watchlistTable = document.getElementById('watchlistTable');

    // Clear existing content
    watchlistTable.innerHTML = '';

    // Iterate through venues
    data.schedule.venues.forEach(venue => {
        // Create a watchlist for each venue
        createWatchlistForVenue(watchlistTable, venue);
    });

    // Show the watchlist container
    watchlistContainer.style.display = 'block';
}

    function getFirstLastName(fullName) {
        const nameParts = fullName.split(' ');
        return `${nameParts[0]} ${nameParts[nameParts.length - 1].charAt(0)}.`;
    }

        
    function getSelectedCompetitorsForGroup(groupId) {
    const selectedCompetitors = [];
    const checkboxes = document.getElementsByName('competitorCheckbox');

    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            const wcaId = checkbox.value;
            const person = data.persons.find(person => person.wcaId === wcaId);
            if (person) {
                const assignmentsForGroup = person.assignments.filter(assignment =>
                    assignment.activityId === groupId && assignment.assignmentCode === 'competitor'
                );
                if (assignmentsForGroup.length > 0) {
                    selectedCompetitors.push(person.name);
                }
            }
        }
    });

    return selectedCompetitors;
}

function getSelectedJudgesForGroup(groupId) {
    return getSelectedPersonsForGroupAndAssignment(groupId, 'staff-judge');
}

function getSelectedScramblersForGroup(groupId) {
    return getSelectedPersonsForGroupAndAssignment(groupId, 'staff-scrambler');
}

function getSelectedRunnersForGroup(groupId) {
    return getSelectedPersonsForGroupAndAssignment(groupId, 'staff-runner');
}

function getSelectedPersonsForGroupAndAssignment(groupId, assignmentCode) {
    const selectedPersons = [];
    const checkboxes = document.getElementsByName('competitorCheckbox');

    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            const wcaId = checkbox.value;
            const person = data.persons.find(person => person.wcaId === wcaId);
            if (person) {
                const assignmentsForGroup = person.assignments.filter(assignment =>
                    assignment.activityId === groupId && assignment.assignmentCode === assignmentCode
                );
                if (assignmentsForGroup.length > 0) {
                    selectedPersons.push(person.name);
                }
            }
        }
    });

    return selectedPersons;
}

        function createWatchlistForVenue(watchlistTable, venue) {
    // Initialize an array to store sorted groups
    const headerRow = watchlistTable.insertRow(0);
    const headers = ["Time", "Event", "Compete", "Judge", "Scramble", "Run"];

    headers.forEach(headerText => {
        const headerCell = headerRow.insertCell();
        headerCell.textContent = headerText;
    });

    // Initialize an array to store sorted groups
    const sortedGroups = [];

    // Iterate through activities in the venue
    venue.rooms.forEach(room => {
        room.activities.forEach(activity => {
            // Check if the activity has child activities
            if (activity.childActivities && activity.childActivities.length > 0) {
                activity.childActivities.forEach(group => {
                    // Extract round and group numbers from the activity code
                    const [event, round, groupNumber] = group.activityCode.split('-').map(item => item.trim());

                    // Push group information into the array
                    sortedGroups.push({
                        startTime: new Date(group.startTime),
                        event,
                        round,
                        groupNumber,
                        id: group.id,
                    });
                });
            }
        });
    });

    // Sort the groups based on start time
    sortedGroups.sort((a, b) => a.startTime - b.startTime);

    // Iterate through sorted groups and populate the table
    sortedGroups.forEach(group => {
        // Populate the table with data
        const row = watchlistTable.insertRow(-1);

        // Add group information in the first two columns
        const startTimeCell = row.insertCell(0);
        startTimeCell.textContent = convertUtcToLocalTime(group.startTime);

        // Display the event, round, and group numbers
        const groupNameCell = row.insertCell(1);
        groupNameCell.textContent = `${getEventName(group.event)} | ${group.round[1]}, ${group.groupNumber[1]}`;

        // Add "Compete" column
        const competeCell = row.insertCell(2);
        const selectedCompetitors = getSelectedCompetitorsForGroup(group.id);
        competeCell.innerHTML = selectedCompetitors.map(name => getFirstLastName(name)).join(', ');

        // Add "Judge" column
        const judgeCell = row.insertCell(3);
        const selectedJudges = getSelectedJudgesForGroup(group.id);
        judgeCell.innerHTML = selectedJudges.map(name => getFirstLastName(name)).join(', ');

        // Add "Scramble" column
        const scrambleCell = row.insertCell(4);
        const selectedScramblers = getSelectedScramblersForGroup(group.id);
        scrambleCell.innerHTML = selectedScramblers.map(name => getFirstLastName(name)).join(', ');

        // Add "Run" column
        const runCell = row.insertCell(5);
        const selectedRunners = getSelectedRunnersForGroup(group.id);
        runCell.innerHTML = selectedRunners.map(name => getFirstLastName(name)).join(', ');
    });
}



        function convertUtcToLocalTime(utcTimeString) {
            const utcTime = new Date(utcTimeString);
            const localTime = utcTime.toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
                weekday: 'short',
                hour: 'numeric',
                minute: 'numeric',
                hour12: true,
            });
            return localTime;
        }
        
	function exportToPdf() {
    const watchlistTable = document.getElementById('watchlistTable');

    // Initialize the document definition for pdfmake
    const documentDefinition = {
        content: [
            {
                table: {
                    body: [['Time', 'Event', 'Compete', 'Judge', 'Scramble', 'Run']]
                },
                layout: 'lightHorizontalLines'
            }
        ]
    };

    // Populate the pdfmake document definition with data from the watchlistTable
    for (let i = 1; i < watchlistTable.rows.length; i++) {
        const row = watchlistTable.rows[i];
        const rowData = [];

        // Iterate through cells in the row
        for (let j = 0; j < row.cells.length; j++) {
            rowData.push(row.cells[j].textContent);
        }

        // Add the row data to the document definition
        documentDefinition.content[0].table.body.push(rowData);
    }

    // Create the PDF
    const pdf = pdfMake.createPdf(documentDefinition);

    // Download the PDF
    pdf.download('watchlist.pdf');
}

	    
	function getEventName(eventId) {
	    const eventMap = {
	        '222': '2x2',
	        '333': '3x3',
	        '444': '4x4',
		'555': '5x5',
		'666': '6x6',
		'777': '7x7',
		'333bf': '3BLD',
		'333fm': 'FMC',
		'333oh': '3x3 OH',
		'clock': 'Clock',
		'minx': 'Mega',
		'pyram': 'Pyra',
		'skewb': 'Skewb',
		'sq1': 'Squan',
		'444bf': '4BLD',
		'555bf': '5BLD',
		'333mbf': 'MBLD',
	        // Add more event IDs and names as needed
	    };
	
	    return eventMap[eventId] || 'Unknown Event';
	}
	
window.addEventListener('load', function() {
	    console.log('Page has fully loaded.');
	    initializeFriendsList(); // Call your initialization function here
	    // Additional actions you want to perform when the page opens
	});
</script>

</body>

</html>
